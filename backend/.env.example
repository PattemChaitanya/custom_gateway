# Copy to .env and fill values for local development
DATABASE_URL=sqlite+aiosqlite:///./dev.db
# Minimal required secrets for running locally. Replace these with secure values
# before deploying to production. Use a secrets manager in production.
JWT_SECRET="$(python -c 'import secrets; print(secrets.token_urlsafe(48))')"
REFRESH_TOKEN_SALT="$(python -c 'import secrets; print(secrets.token_urlsafe(48))')"

# Other envs
SQL_ECHO=False

# api_management_prod_salt_secret
SECRET_KEY=$(python -c 'import secrets; print(secrets.token_urlsafe(48))')
# api_management_prod_salt
ENCRYPTION_SALT="$(python -c 'import secrets; print(secrets.token_urlsafe(48))')"

# Postgres example for production
# DATABASE_URL=postgresql+asyncpg://user:password@db-host:5432/dbname

# In production, set JWT_SECRET and REFRESH_TOKEN_SALT to strong, rotated values
# and store them in your secrets manager / CI secrets rather than in the filesystem.

# --- AWS / Postgres placeholders -------------------------------------------------
# If you prefer providing DB parts separately, set these values and the app will
# build the `postgresql+asyncpg://` URL from them.
# Copy the lines below into `.env` and fill with your EC2/Postgres values.
# Example:
AWS_DB_HOST=database-1.cteiwsow8b4a.ap-south-1.rds.amazonaws.com
AWS_DB_NAME=postgres
AWS_DB_USER=postgres
AWS_DB_PASSWORD=(^$)2Chaitu
AWS_DB_PORT=5432
AWS_REQUIRE_SSL=require
# Leave the cert paths empty unless you have the RDS CA bundle downloaded
AWS_DB_SSL_FILE_PATH=
AWS_SSLROOTCERT=

